package best_practices

import cats.syntax.all._

object StronglyTypedFunctions {

  trait User
  // this sucks, becauase username and email are String types which is too general
  // problems:
  // - input order can be mismatched
  // - invalid data can be passed, such as "john#   %gmail.com"
  // Solution - value classes
  def login[F[_]](username: String, email: String): F[Option[User]] = ???


  object value_classes {
    // extending AnyVal makes sure that we avoid runtime costs
    final case class Username(value: String) extends AnyVal
    final case class Email(value: String)    extends AnyVal

    def betterLookup[F[_]](username: Username, email: Email): F[Option[User]] = ???
    // better but can be improved
    // technique: Smart Constructors - make primary constructors private and expose smart constructors via companion objects
  }

  object smart_constructors {
    // sealed - forbid other classes to extend our value classes outside the source file
    // abstract - forbid to do something like new Email("") & remove autogenerated copy() and apply()
    sealed abstract case class Username private (value: String)
    sealed abstract case class Email private (value: String)

    // now, with smart constructors it's impossible to represent invalid data
    object Username {
      def fromString(input: String): Option[Username] =
        input.nonEmpty.guard[Option].as(new Username(input) {})

      def fromStringAlternative(input: String): Option[Username] =
        Option.when(input.nonEmpty)(new Username(input) {})

      def fromStringVerbose(input: String): Option[Username] =
        if (input.nonEmpty) Some(new Username(input) {})
        else None
    }

    object Email {
      def fromString(input: String): Option[Email] =
        input.nonEmpty.guard[Option].as(new Email(input) {})
    }

    def betterLookup[F[_]](username: Username, email: Email): F[Option[User]] = ???

    // beautiful, isn't it?
    def client: Unit = {
      (Username.fromString("Chicco"), Email.fromString("Chicco@gmail.com")).mapN { (username, email) =>
        betterLookup(username, email)
      }
    }

  }

  // we solved one problem but others appeared:
  // - no guarantees about having 0 additional memory alloc

  // recommendation:
  // - avoid value classes (AnyVal) and sealed abstract case classes and use @newtype library
  // @newtype gives zero cost wrappers with no runtime overhead

  object newtypes {
    import io.estatico.newtype.macros._

    @newtype case class Username(value: String)
    @newtype case class Email(value: String)

    // Newtypes do not solve validation; they are just zero-cost wrappers
    // so smart constructors still needed
  }





}
